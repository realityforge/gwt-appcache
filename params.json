{"name":"Gwt-appcache","tagline":"GWT AppCache Support Library","body":"gwt-appcache\r\n============\r\n\r\n[![Build Status](https://secure.travis-ci.org/realityforge/gwt-appcache.png?branch=master)](http://travis-ci.org/realityforge/gwt-appcache)\r\n\r\nThe HTML5 Appcache specification is a mechanism for enabling offline\r\nHTML5 applications. This library provides a simple way to generate the\r\nrequired cache manifests and serve a separate manifest for each separate\r\npermutation. The library also provides support for the browser side aspects\r\nof the appcache specification. See the appendix section includes further\r\nreferences concerning the appcache spec.\r\n\r\nQuick Start\r\n-----------\r\n\r\nThe simplest way to appcache enable a GWT application is to;\r\n\r\n* add the following dependencies into the build system. i.e.\r\n\r\n```xml\r\n<dependency>\r\n   <groupId>org.realityforge.gwt.appcache</groupId>\r\n   <artifactId>gwt-appcache-client</artifactId>\r\n   <version>1.0.2</version>\r\n   <scope>provided</scope>\r\n</dependency>\r\n<dependency>\r\n   <groupId>org.realityforge.gwt.appcache</groupId>\r\n   <artifactId>gwt-appcache-linker</artifactId>\r\n   <version>1.0.2</version>\r\n   <scope>provided</scope>\r\n</dependency>\r\n<dependency>\r\n   <groupId>org.realityforge.gwt.appcache</groupId>\r\n   <artifactId>gwt-appcache-server</artifactId>\r\n   <version>1.0.2</version>\r\n</dependency>\r\n```\r\n\r\n* add the following snippet into the .gwt.xml file.\r\n\r\n```xml\r\n<module rename-to='myapp'>\r\n  ...\r\n\r\n  <!-- Enable the client-side library -->\r\n  <inherits name=\"org.realityforge.gwt.appcache.Appcache\"/>\r\n\r\n  <!-- Enable the linker -->\r\n  <inherits name=\"org.realityforge.gwt.appcache.linker.Linker\"/>\r\n\r\n  <!-- enable the linker that generates the manifest -->\r\n  <add-linker name=\"appcache\"/>\r\n\r\n  <!-- configure all the static files not managed by the GWT compiler -->\r\n  <extend-configuration-property name=\"appcache_static_files\" value=\"./\"/>\r\n  <extend-configuration-property name=\"appcache_static_files\" value=\"index.html\"/>\r\n</module>\r\n```\r\n\r\n* configure html that launches the application to look for the manifest.\r\n\r\n```xml\r\n<!doctype html>\r\n<html manifest=\"myapp.appcache\">\r\n   ...\r\n</html>\r\n```\r\n\r\n* declare the servlet that serves the manifest.\r\n\r\n```java\r\n@WebServlet( urlPatterns = { \"/myapp.manifest\" } )\r\npublic class ManifestServlet\r\n  extends AbstractManifestServlet\r\n{\r\n  public ManifestServlet()\r\n  {\r\n    addPropertyProvider( new UserAgentPropertyProvider() );\r\n  }\r\n}\r\n```\r\n\r\n* interact with the application from within the browser.\r\n\r\n```java\r\nfinal ApplicationCache cache = ApplicationCache.getApplicationCacheIfSupported();\r\nif ( null != cache )\r\n{\r\n  cache.addUpdateReadyHandler( new UpdateReadyEvent.Handler()\r\n  {\r\n    @Override\r\n    public void onUpdateReadyEvent( @Nonnull final UpdateReadyEvent event )\r\n    {\r\n      //Force a cache update if new version is available\r\n      cache.swapCache();\r\n    }\r\n  } );\r\n\r\n  // Ask the browser to recheck the cache\r\n  cache.requestUpdate();\r\n\r\n  ...\r\n```\r\n\r\n\r\nThis should be sufficient to get your application using the appcache. If you\r\nload the application in a modern browser you should see it making use of the\r\ncache in the console.\r\n\r\nA very simple example of this code is available in the\r\n[gwt-appcache-example](https://github.com/realityforge/gwt-appcache-example)\r\nproject.\r\n\r\nHow does it work?\r\n-----------------\r\n\r\nFor every permutation generated by the GWT compiler, a separate manifest file\r\nis generated. The manifest includes almost all public resources generated by\r\nGWT with the exception of some used during debugging and development (i.e.\r\n`myapp.devmode.js` and `compilation-mappings.txt`). The manifest also includes\r\nany additional files declared using the \"`appcache_static_files`\" configuration\r\nsetting.\r\n\r\nAfter the GWT compiler has generated all the different permutations, a single\r\nxml descriptor `permutations.xml` is generated that lists all the permutations\r\nand the  deferred-binding properties that were used to uniquely identify the\r\npermutations. Typically these include values of properties such as \"`user.agent`\".\r\n\r\nIf the compiler is using soft permutations then it is possible that multiple\r\ndeferred-binding properties will be served using a single permutation, in which\r\ncase the descriptor will have comma separated values in the `permutations.xml`\r\nfor that permutation.\r\n\r\nThe manifest servlet is then responsible for reading the `permutations.xml` and\r\ninspecting the incoming request and generating properties that enable it to select\r\nthe correct permutation and thus the correct manifest file. The selected manifest\r\nfile is returned to the requester.\r\n\r\nHow To: Define a new Selection Configuration\r\n--------------------------------------------\r\n\r\nSometimes it is useful to define a new configuration property in the gwt module\r\ndescriptors that will define new permutations. A fairly typical example would\r\nbe to define a configuration property that defines different view modalities.\r\ni.e. Is the device phone-like, tablet-like or a desktop. This would drive the\r\nui and workflow in the application.\r\n\r\nStep 1 is to define the configuration in the gwt module descriptor. i.e.\r\n\r\n```xml\r\n<define-property name=\"ui.modality\" values=\"phone, tablet, desktop\"/>\r\n  <property-provider name=\"ui.modality\"><![CDATA[\r\n  {\r\n    var ua = window.navigator.userAgent.toLowerCase();\r\n    if ( ua.indexOf('android') != -1 ) { return 'phone'; }\r\n    if ( ua.indexOf('iphone') != -1 ) { return 'phone'; }\r\n    if ( ua.indexOf('ipad') != -1 ) { return 'tablet'; }\r\n    return 'desktop';\r\n  }\r\n]]></property-provider>\r\n```\r\n\r\nStep 2 is to use the new configuration property to control the deferred binding\r\nrules in gwt modules. For example, the following could be added to a .gwt.xml\r\nmodule file;\r\n\r\n```xml\r\n<replace-with class=\"com.biz.client.gin.DesktopInjectorWrapper\">\r\n  <when-type-is class=\"com.biz.client.gin.InjectorWrapper\"/>\r\n  <when-property-is name=\"ui.modality\" value=\"desktop\"/>\r\n</replace-with>\r\n\r\n<replace-with class=\"com.biz.client.gin.TabletInjectorWrapper\">\r\n  <when-type-is class=\"com.biz.client.gin.InjectorWrapper\"/>\r\n  <when-property-is name=\"ui.modality\" value=\"tablet\"/>\r\n</replace-with>\r\n\r\n<replace-with class=\"com.biz.client.gin.PhoneInjectorWrapper\">\r\n  <when-type-is class=\"com.biz.client.gin.InjectorWrapper\"/>\r\n  <when-property-is name=\"ui.modality\" value=\"phone\"/>\r\n</replace-with>\r\n```\r\n\r\nStep 3 is to define a property provider for your new configuration property and\r\nadd it to the manifest servlet. i.e.\r\n\r\n```java\r\npublic class UIModalityPropertyProvider\r\n  implements PropertyProvider\r\n{\r\n  @Override\r\n  public String getPropertyValue( final HttpServletRequest request )\r\n  {\r\n    final String ua = request.getHeader( \"User-Agent\" ).toLowerCase();\r\n    if ( ua.contains( \"android\" ) || ua.contains( \"phone\" ) ) { return \"phone\"; }\r\n    else if ( ua.contains( \"ipad\" ) ) { return \"tablet\"; }\r\n    else { return \"desktop\"; }\r\n  }\r\n\r\n  @Override\r\n  public String getPropertyName()\r\n  {\r\n    return \"ui.modality\";\r\n  }\r\n}\r\n```\r\n\r\n```java\r\n@WebServlet( urlPatterns = { \"/myapp.manifest\" } )\r\npublic class ManifestServlet\r\n  extends AbstractManifestServlet\r\n{\r\n  public ManifestServlet()\r\n  {\r\n    addPropertyProvider( new UIModalityPropertyProvider() );\r\n    addPropertyProvider( new UserAgentPropertyProvider() );\r\n  }\r\n}\r\n```\r\n\r\nThis example demonstrates a simple mechanism for supporting server-side derivable\r\nconfiguration properties to select a permutation. In some cases, the selection\r\nproperty can only be determined on the client. This scenario is more complex and\r\nrequires a combination of cookies and dynamic host pages to address.\r\n\r\nHow To: Define a new client-side selection Configuration\r\n--------------------------------------------------------\r\n\r\nSometimes configuration properties can only be determined on the client. A good\r\nexample is the device pixel density that can be determined by inspecting the\r\n\"window.devicePixelRatio\" property in the browser.\r\n\r\n```xml\r\n<define-property name=\"pixel.density\" values=\"high, low\"/>\r\n  <property-provider name=\"pixel.density\"><![CDATA[\r\n  {\r\n  if(window.devicePixelRatio >= 2) { return 'high'; }\r\n  return 'low';\r\n  }\r\n]]></property-provider>\r\n```\r\n\r\nThe gwt-appcache library can defer the selection of the property to the client-side\r\nby merging the manifests of the high and low density permutations and returning\r\nthe merged manifest to the client. This is done by marking the \"pixel.density\"\r\n property as client-side via;\r\n\r\n```java\r\n@WebServlet( urlPatterns = { \"/myapp.manifest\" } )\r\npublic class ManifestServlet\r\n  extends AbstractManifestServlet\r\n{\r\n  public ManifestServlet()\r\n  {\r\n    addPropertyProvider( new UserAgentPropertyProvider() );\r\n    ...\r\n    addClientSideSelectionProperty( \"pixel.density\" );\r\n  }\r\n}\r\n```\r\n\r\nThis will mean that the client ultimately caches extra data that may not be used\r\nby the client. This may be acceptable for small applications but a better approach\r\nis to detect the pixel density and set a cookie prior to navigating to the page\r\nthat hosts the application. The server can then attempt to determine the value of\r\nthe configuration property using the cookie name like;\r\n\r\n\r\n```java\r\npublic class PixelDensityPropertyProvider\r\n  implements PropertyProvider\r\n{\r\n  @Override\r\n  public String getPropertyName() { return \"pixel.density\"; }\r\n\r\n  @Override\r\n  public String getPropertyValue( HttpServletRequest request )\r\n  {\r\n    final Cookie[] cookies = request.getCookies();\r\n    if ( null != cookies )\r\n    {\r\n      for ( final Cookie cookie : cookies )\r\n      {\r\n        if ( \"pixel.density\".equals( cookie.getName() ) )\r\n        {\r\n          return cookie.getValue();\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n}\r\n```\r\n\r\n```java\r\n@WebServlet( urlPatterns = { \"/myapp.manifest\" } )\r\npublic class ManifestServlet\r\n  extends AbstractManifestServlet\r\n{\r\n  public ManifestServlet()\r\n  {\r\n    addPropertyProvider( new UserAgentPropertyProvider() );\r\n    addPropertyProvider( new PixelDensityPropertyProvider() );\r\n    ...\r\n    addClientSideSelectionProperty( \"pixel.density\" );\r\n  }\r\n}\r\n```\r\n\r\nHow To: Integrate into existing framework\r\n-----------------------------------------\r\n\r\nThe gwt-appcache library was designed to be easy to integrate into any other\r\ngwt framework. A good example is the wonderful [MGWT](https://github.com/dankurka/mgwt)\r\nlibrary from which this project was initially derived. MGWT selects the permutation\r\nbased on the following configuration properties;\r\n\r\n* `mgwt.os` - `iphone`, `iphone_retina`, `ipad`, `ipad_retina`, `android`, `android_tablet`, `blackberry` etc.\r\n* `mobile.user.agent` - `mobilesafari` vs `not_mobile`.\r\n* `user.agent` - A standard gwt configuration property.\r\n* `phonegap.env` - Always `no` for web applications.\r\n\r\nIt is important to the MGWT framework to distinguish between retina and non-retina versions of\r\nthe iphone and ipad variants. The retina versions inspect the `window.devicePixelRatio` browser property\r\nsimilarly to the above `pixel.density` example. Rather than making this a separate configuration\r\nproperty, MGWT conflates this with operating system. As a result it uses a custom strategy to\r\nmerge the multiple permutations manifests as can be observed at [AbstractMgwtManifestServlet](https://github.com/realityforge/gwt-appcache/blob/master/server/src/main/java/org/realityforge/gwt/appcache/server/mgwt/AbstractMgwtManifestServlet.java#L15-L62).\r\nMGWT also defines several [property providers](https://github.com/realityforge/gwt-appcache/tree/master/server/src/main/java/org/realityforge/gwt/appcache/server/mgwt).\r\nThere is a [pull request](https://github.com/dankurka/mgwt/pull/37) where you can look at the\r\nwork required to re-integrate the functionality back into the MGWT framework. This is a good\r\nexample of complex integration of `gwt-appcache`.\r\n\r\nAppendix\r\n--------\r\n\r\n* [A Beginner's Guide to Using the Application Cache](http://www.html5rocks.com/en/tutorials/appcache/beginner/)\r\n* [Appcache Facts](http://appcachefacts.info/)\r\n* [Offline Web Application Standard](http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html)\r\n\r\nCredit\r\n------\r\n\r\nThis library began as a enhancement of similar functionality in the\r\n[MGWT](https://github.com/dankurka/mgwt) project by Daniel Kurka. All\r\ncredit goes to Daniel for the initial code and idea. The library is also\r\ninspired by work done by the [rebar](https://github.com/bedatadriven/rebar)\r\nproject. Thanks goes out to them as well.\r\n","google":"UA-41755265-2","note":"Don't delete this file! It's used internally to help with page regeneration."}